package hub

import (
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/floeit/floe/client"
	"github.com/floeit/floe/config"
	"github.com/floeit/floe/event"
	"github.com/floeit/floe/log"
	"github.com/floeit/floe/path"
	"github.com/floeit/floe/store"
)

// This file contains all functions that deal with events that may or may not
// be serviced on this host i.e. pending runs.

// some special system event tags, generated by the system internals rather than the configurable nodes
const (
	tagEndFlow     = "sys.end.all"       // a run has ended
	tagNodeUpdate  = "sys.node.update"   // an executing node has had an update to its output
	tagNodeStart   = "sys.node.start"    // an executing node has started its job
	tagStateChange = "sys.state"         // a run has transitioned state
	tagWaitingData = "sys.data.required" // a node in the run needs data input
	tagGoodTrigger = "trigger.good"      // always issued when a trigger

	inboundPrefix = "inbound" // the tags from any data push events
)

var zt = time.Time{} // zero time

// node definitions
type refNode interface {
	NodeRef() config.NodeRef
	GetTag(string) string
}

type mergeNode interface {
	refNode
	TypeOfNode() string
	Waits() int
}

// Hub links events to the config rules
type Hub struct {
	sync.RWMutex

	basePath  string         // the configured basePath for the hub
	cachePath string         // folder to cache working files
	hostID    string         // the id fo this host
	config    *config.Config // the config rules
	queue     *event.Queue   // the event q to route all events

	// any registered timers
	timers *timers

	// tags
	tags []string // the tags that

	// hosts lists all the hosts
	hosts []*client.FloeHost

	// runs contains list of runs ongoing or the archive
	// this is the only ongoing changing state the hub manages
	// the runstore is responsible for persisting any state
	runs *RunStore
}

// New creates a new hub with the given config
func New(host, tags, basePath, adminTok string, c *config.Config, storage store.Store, q *event.Queue) *Hub {
	// create all tags
	l := strings.Split(tags, ",")
	tagList := []string{}
	for _, t := range l {
		tagList = append(tagList, strings.TrimSpace(t))
	}
	basePath, err := path.Expand(basePath)
	if err != nil {
		log.Fatal("can not set base path", err)
	}
	h := &Hub{
		hostID:    host,
		tags:      tagList,
		basePath:  basePath,
		cachePath: filepath.Join(basePath, "fetch_cache"),
		config:    c,
		queue:     q,
		runs:      newRunStore(storage),
	}
	// make sure the cache exists
	err = os.MkdirAll(h.cachePath, 0700)
	if err != nil {
		log.Fatal("can not create the cache path", err)
	}

	h.timers = newTimers(h)
	// setup hosts
	h.setupHosts(adminTok)
	// set up any timed triggers
	h.launchTimedTriggers()
	// hub subscribes to its own queue
	h.queue.Register(h)
	// start checking the pending queue
	go h.serviceLists()

	return h
}

// Notify is called whenever an event is sent to the hub, satisfying event.Observer.
// This is the central dispatch of the two main event types adopted and un-adopted.
func (h *Hub) Notify(e event.Event) {
	// if the event has not been previously adopted in any pending run then it is a trigger event
	if !e.RunRef.Adopted() {
		err := h.pendFlowFromTrigger(e)
		if err != nil {
			log.Error(err)
		}
		return
	}
	// otherwise it is an adopted run specific event so and is directed to this host
	h.dispatchToActive(e)
}

// HostID returns the id for this host
func (h *Hub) HostID() string {
	return h.hostID
}

// Tags returns the server tags
func (h *Hub) Tags() []string {
	return h.tags
}

// AllClientRuns queries all hosts for their summaries for the given run ID
func (h *Hub) AllClientRuns(flowID string) client.RunSummaries {
	s := client.RunSummaries{}
	for _, host := range h.hosts {
		summaries := host.GetRuns(flowID)
		s.Append(summaries)
	}
	return s
}

// AllClientFindRun queries all hosts for the specified run
func (h *Hub) AllClientFindRun(flowID, runID string) *client.Run {
	for _, host := range h.hosts {
		run := host.FindRun(flowID, runID)
		if run != nil {
			return run
		}
	}
	return nil
}

// AllHosts returns all the hosts
func (h *Hub) AllHosts() map[string]client.HostConfig {
	h.Lock()
	defer h.Unlock()
	r := map[string]client.HostConfig{}
	for _, host := range h.hosts {
		c := host.GetConfig()
		r[c.HostID] = c
	}
	return r
}

// Config returns the config for this hub
func (h *Hub) Config() config.Config {
	return *h.config
}

// AllRuns returns all the runs for this hub.
func (h *Hub) AllRuns(id string) (pending Runs, active Runs, archive Runs) {
	return h.runs.allRuns(id)
}

// FindRun returns an individual run as given by the flow and run.
func (h *Hub) FindRun(flowID, runID string) *Run {
	return h.runs.find(flowID, runID)
}

// Queue returns the hubs queue
func (h *Hub) Queue() *event.Queue {
	return h.queue
}

func (h *Hub) setupHosts(adminTok string) {
	h.Lock()
	defer h.Unlock()
	// TODO - consider host discovery via various mechanisms
	// e.g. etcd, dns, env vars or direct k8s api
	for _, hostAddr := range h.config.Common.Hosts {
		log.Debug("connecting to host", hostAddr)
		addr := hostAddr + h.config.Common.BaseURL
		h.hosts = append(h.hosts, client.New(addr, adminTok))
	}
}

func (h *Hub) launchTimedTriggers() {
	for _, f := range h.config.Flows {
		for _, t := range f.Triggers {
			if t.Type == "timer" || t.Type == "repo" {
				h.timers.register(config.FlowRef{ID: f.ID, Ver: f.Ver}, t.ID, t.Opts, startFlowTrigger)
			}
		}
	}
}
